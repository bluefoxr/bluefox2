---
title: "Twelve (interesting?) things you can do in COINr"
author: Will Becker
bg_image: images/featue-bg.jpg
categories:
- Indicators
date: "2021-06-22"
description: Updates from my R package
draft: false
image: images/blog/Rlogo.png
tags:
- Indicators
- R
type: post
---

COINr is an open-source R package for building and analysing composite indicators, developed by the European Commission's [Joint Research Centre](https://knowledge4policy.ec.europa.eu/composite-indicators/about_en). The COINr package has many functionalities, and the full documentation can be found [here](https://bluefoxr.github.io/COINrDoc/). Here, a few highlights are given.

All of the highlights will be demonstrated on COINr's inbuilt "ASEM data set", which is a composite indicator created to measure international *sustainable connectivity*, and is based on the indexes found at the [ASEM Sustainable Connectivity Portal](https://composite-indicators.jrc.ec.europa.eu/asem-sustainable-connectivity/).

We will begin by building this in COINr:

```{r, collapse=TRUE}
library(COINr)
library(magrittr)
ASEM <- build_ASEM()
```

<br/><font size="4"> **Build with no limits** </font>

COINr has a rich set of tools for constructing composite indicators from raw indicator data. Unlike other composite indicator tools, COINr has very few limits. Construction features include:

* No limits on the number of indicators, units (i.e. countries/regions), or number of aggregation levels. Your composite indicator can be the size and shape you want it to be.
* Denomination by other indicators (including built in world denominators data set)
* Screening units by data requirements
* Imputation of missing data, by either:
    - Global mean or median of indicator values
    - Group mean or median of indicator values
    - Mean or median within an aggregation group
    - Expectation maximisation algorithm
* Normalisation by any of the following methods, either for all indicators or for each individually:
    - Min max
    - Z-score
    - Linear scale
    - Rank
    - Borda
    - Percentile rank
    - Fraction of maximum indicator value
    - Distance to a reference unit
    - Distance to maximum indicator value
    - Distance to indicator target
    - Custom normalisation function
* Weighting using either:
    - Equal weighting
    - Manual weighting (including an interactive reweighting app)
    - PCA weights
    - Correlation-optimised weights
* Aggregation of indicators using any of the following for each aggregation level:
    - Arithmetic weighted mean
    - Geometric weighted mean
    - Harmonic weighted mean
    - Median
    - Copeland method
    - A custom aggregation function
    
All of these features are easily accessible via a harmonised "COINrverse" system, which is up next.

<br/><font size="4"> **Live in the COINrverse (or not)** </font>

Many COINr functions can be used two ways: either as standalone functions which operate on a data frame (e.g. normalising a data frame of indicator data), or on a so-called **COIN**.

COINs are hierarchical lists, a bit like a folder system. In R they are sometimes called "lists of lists" or "nested lists". A COIN contains all the data, parameters, methodological choices and results of a composite indicator. It has a structure something like this:

![Inside a COIN](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/COIN_contents_tree.png)

In short, a COIN contains everything relating to your composite indicator in a single "object". There are at least three good reasons for this:

1. A streamlined syntax because functions know where data and parameters are. Therefore, COINr operations typically follow a syntax of the form `COINobj <- COINr_function(COINobj, <methodological settings>)`, updating the COIN object with new results and data sets generated by the function.
2. It keeps things organised and avoids a workspace of dozens of variables.
3. It keeps a record of methodological decisions - this allows results to be easily regenerated following "what if" experiments, such as removing or changing indicators and comparing alternative versions of the same index.

<br/><font size="4"> **All the stats you could want** </font>

Hello stats:

```{r, collapse=TRUE}
getStats(ASEM, dset = "Aggregated", out2 = "list")$StatTable %>% reactable::reactable()
```


<br/><font size="4"> **Easy plots** </font>

COINr provides many different types of plots, all accessible with simple functions. They follow a "plot first, adjust later" logic: because they are powered by the **plotly** and **ggplot2** packages, they can be fine tuned using functions from these packages.

COINr plots include framework plots:

```{r, message=F, warning=F}
plotframework(ASEM)
```

Indicator distribution plots:

```{r, message=F, warning=F}
plotIndDist(ASEM, type = "Violindot", icodes = "Physical")
plotIndDist(ASEM, type = "Box", icodes = "Political")
iplotIndDist(ASEM, dset = "Raw", icodes = "Renew", ptype = "Violin")
```

Barcharts:

```{r}
iplotBar(ASEM, dset = "Raw", isel = "Embs", usel = "SGP")
iplotBar(ASEM, dset = "Aggregated", isel = "Conn", aglev = 3, stack_children = TRUE)
```

Maps:

```{r ASEMindexmap}
iplotMap(ASEM, dset = "Aggregated", isel = "Conn")
```

...And many more!

<br/><font size="4"> **Multivariate analysis** </font>

Analysing a composite indicator is streamlined in COINr by dedicated functions and plots which perform correlation analysis and PCA.

Any aggregation level (and subset thereof) can be correlated and visualised against any other:

```{r, message=F, warning=F}
plotCorr(ASEM, dset = "Aggregated", aglevs = c(1,2), showvals = T)
```

By default in-group correlations are highlighted, but the full correlation matrix can be displayed.

Multi-level correlation tables help to show weak or negatively correlated indicators with each parent level:

```{r, message=F, warning=F}
plotCorr(ASEM, dset = "Aggregated", aglevs = c(1,2), showvals = T, withparent = "family",
         flagcolours = TRUE)
```

Interactive correlation maps are good for html documents:

```{r}
iplotCorr(ASEM, aglevs = c(1,2), showvals = F, flagcolours = F)
```

COINr has bindings to base PCA functions, and can give plots for any aggregation group:

```{r, message=F, warning=F}
library(ggbiplot)
PCAres <- getPCA(ASEM, dset = "Aggregated", aglev = 2, out2 = "list")
ggbiplot(PCAres$PCAresults$Conn$PCAres,
         labels = ASEM$Data$Aggregated$UnitCode,
         groups = ASEM$Data$Aggregated$Group_EurAsia)
```

<br/><font size="4"> **Treat data and visualise** </font>

COINr comes with a flexible set of data treatment options, including:

* Winsorisation of high and/or low values up to thresholds
* Log transformations
* Scaled log transformations
* Box-Cox transformations

Treatment can be applied to all indicators or specified individually for each. Treated and untreated data can compared using an inbuilt app.

```{r, eval=F}
ASEM <- treat(ASEM, dset = "Denominated")

indDash(ASEM)
```

![indDash screenshot](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/inddash_screenshot.png)

<br/><font size="4"> **Full global sensitivity analysis** </font>

COINr calculates rank distributions for each unit, confidence intervals, and a full global sensitivity analysis which gives sensitivity indices for each input assumption. A wide range of assumptions can be varied, from weights to normalisation methods, winsorisation limits, and many more.

```{r, include=F}
SAresults <- readRDS("SAresults_ASEMexample.rds")
SAresults$RankStats
```

```{r plotSAbox}
# plot bar chart
plotSA(SAresults, ptype = "box")
```

# Tweak your weights

Weights can be adjusted via automatic weight optimisation, PCA, or manually. Manual weight adjustments are made easier by a built in reweighting app called `rew8r()`. This is currently being tweaked and is out of action, but would look like this:

```{r, eval=F}
rew8r(ASEM)
```

![rew8r() screenshot](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/rew8r_screenshot.png)

![Correlation scatter plot screenshots in rew8r()](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/corr_scat_screenshot_rew8r.png)
![Correlation scatter plot screenshots in rew8r()](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/corr_scat_sep_screenshot_rew8r.png)

<br/><font size="4"> **Fast prototype results dashboard** </font>

Results can be quickly visualised in an interactive Shiny app. This is not a substitute for a dedicated web portal, but can be a fast first exploration of the results. The app includes tables, unit comparisons, maps and bar charts. Here's a separate example of a radar chart comparison:

```{r radarASEM_groupmean}
iplotRadar(ASEM, dset = "Aggregated", usel = c("CHN", "DEU"), isel = "Conn", aglev = 2, addstat = "groupmean",
           statgroup = "Group_GDP", statgroup_name = "GDP")
```

And a screenshot of the full app...

```{r resultsApp, eval=F}
resultsDash(ASEM)
```

![resultsDash screenshot](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/resultsDash_screenshot.png)

<br/><font size="4"> **Automatic and customisable unit reports** </font>

COINr has a function which calls an R Markdown template, and generates customisable unit reports for any (or all) units. This can be output in Word, pdf, or html format.

```{r, eval=F}
getUnitReport(ASEM, usel = "ITA", out_type = ".docx")
```


![Unit profile screenshot 1/2](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/getUnitProfile_screenshot1.png)
![Unit profile screenshot 2/2](/english/blog/2021-06-22-TenThingsYouCanDoInCOINr_files/getUnitProfile_screenshot2.png)

<br/><font size="4"> **Compare versions** </font>

To adjust and compare versions of COINs, we simply:

1. Copy the COIN
2. Adjust the index methodology or data by editing the `.$Method` folder and/or the underlying data
3. Regenerate the results
4. Compare alternatives

```{r ASEMAltNorm}
# Make a copy
ASEMAltNorm <- ASEM

# Edit .$Method
ASEMAltNorm$Method$normalise$ntype <- "borda"

# Regenerate
ASEMAltNorm <- regen(ASEMAltNorm, quietly = TRUE)
```

We now make a comparison table:

```{r}
compTable(ASEM, ASEMAltNorm, dset = "Aggregated", isel = "Index") #%>%
  #head(10) %>%
  #knitr::kable()
```

<br/><font size="4"> **Import and export** </font>

While you can get your data in and out of R in any way you want with R's myriad packages, COINr has a couple of handy interfaces.

1. The `coin_2excel()` function writes all data, analysis and results to a single Excel workbook in one command.
2. The `COINToolIn()` function reads a COIN Tool workbook and automatically imports everything into COINr.
